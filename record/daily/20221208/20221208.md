
Daily Record 20221208
=====================

## 流水

实验指导书；

## 知识点

##### 内存碎片

无法被分配和使用的空闲内存空间。

**内碎片**：已被分配出去内存区域，占有这些区域的应用并不适用这块区域，操作系统也无法利用这块区域；

**外碎片**：还没被分配出去内存空闲区域，由于太小而无法分配给提出申请内存空间的应用；

##### 静态分配

我们在程序中能够直接看到的变量都是被静态分配在栈或者全局数据段上的，大小在编译器已知；

通过对确定大小的指针来实现对编译时大小不确定的堆数据的访问；

##### 动态分配

静态分配在数据段中的全局变量在应用的整个运行期间均存在。

局部变量被静态分配在它所在的函数的栈帧中，一旦函数返回，这个局部变量的生命周期也就结束了；

动态分配允许我们构造一种并不一直存在，也不绑定函数调用的变量声明周期，周期是自malloc拿到变量指针到free将它收回这段时间内，可以作为变量在函数间传递。

##### 资源获取即初始化RAII （Resource Acquisition Is Initialization）

将一个使用前必须获取的资源的生命周期绑定到一个变量上，变量释放时，对应的资源也一并释放；

##### Rust中的堆数据结构

1. ##### 智能指针Smart Pointer

   `Box<T>`;

   `Rc<T>`;

   `Arc<T>` 功能与`Rc<T>`类似，只是前者用于多线程，后者用于单线程；

   `RefCell<T>`其借用检查在运行时进行，可以在其自身是不可变的情况下修改其内部的值，称为**内部可变性**；只能用于单线程；<u>不会在堆上分配内存</u>，仅用于基于数据段的静态内存分配；

   `Mutex<T>`多线程中使用，保护堆上的变量在同一时间只有一个线程能对它进行操作，保证并发安全，也能提供**内部可变性**；可以视为`RefCell`的多线程版本；

   Rust中有三种指针，三者都指向地址空间中的另一个区域并包含它的位置信息。

   - 智能指针

     不仅包含地址范围，还包含一些其他信息，起到管理和控制的功能，属于一种胖指针；

   - 裸指针`*const T/*mut T`

     等价于C/C++里面的普通指针`T*`, 内容仅仅是一个地址，编译器只进行可变性检查；

   - 引用`&T/&mut T`;

     地址范围，编译器会进行借用检查；

2. ##### 集合Collection （容器Container）

   ```
   Vec<T>
   BTreeMap<K, V>
   BTreeSet<T>
   LinkedList<T>
   VecDeque<T>
   String
   ```

   

## 总结



## 下次学习入口



##### [返回Home](../../../README.md)


